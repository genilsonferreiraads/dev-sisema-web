{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\genil\\\\Desktop\\\\sistema da imperio\\\\src\\\\components\\\\VideoPlayer.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { videoService } from '../lib/supabase';\nimport VideoSidebar from './VideoSidebar';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const VideoPlayer = ({\n  videoId,\n  onEnded,\n  autoplay = false,\n  isPlaying = false,\n  setIsPlaying = () => {},\n  shouldAutoplay = false\n}) => {\n  _s();\n  var _videos$2;\n  const [videos, setVideos] = useState([]);\n  const [newVideoUrl, setNewVideoUrl] = useState('');\n  const [error, setError] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\n  const [selectedVideo, setSelectedVideo] = useState(null);\n  const [player, setPlayer] = useState(null);\n  const [isPlayerReady, setIsPlayerReady] = useState(false);\n  const [localIsPlaying, setLocalIsPlaying] = useState(isPlaying);\n  const updatePlayingState = state => {\n    setLocalIsPlaying(state);\n    setIsPlaying(state);\n  };\n  useEffect(() => {\n    loadVideos();\n  }, []);\n  const loadYouTubeAPI = () => {\n    return new Promise(resolve => {\n      var _firstScriptTag$paren;\n      const existingScript = document.querySelector('script[src=\"https://www.youtube.com/iframe_api\"]');\n      if (existingScript) {\n        if (window.YT && window.YT.Player) {\n          resolve();\n          return;\n        }\n      }\n      const tag = document.createElement('script');\n      tag.src = 'https://www.youtube.com/iframe_api';\n      tag.async = true;\n      const firstScriptTag = document.getElementsByTagName('script')[0];\n      (_firstScriptTag$paren = firstScriptTag.parentNode) === null || _firstScriptTag$paren === void 0 ? void 0 : _firstScriptTag$paren.insertBefore(tag, firstScriptTag);\n      window.onYouTubeIframeAPIReady = () => {\n        resolve();\n      };\n    });\n  };\n  const initializePlayer = async (videoId, shouldAutoplay = false) => {\n    try {\n      var _YT;\n      await loadYouTubeAPI();\n      if (!((_YT = window.YT) !== null && _YT !== void 0 && _YT.Player)) {\n        setError('API do YouTube não está disponível');\n        return null;\n      }\n      if (player) {\n        try {\n          player.destroy();\n        } catch (e) {\n          console.error('Erro ao destruir player existente:', e);\n        }\n        setPlayer(null);\n      }\n      const playerContainer = document.getElementById('youtube-player');\n      if (!playerContainer) {\n        setError('Container do player não encontrado');\n        return null;\n      }\n\n      // Limpa o container antes de criar um novo player\n      while (playerContainer.firstChild) {\n        playerContainer.removeChild(playerContainer.firstChild);\n      }\n      const newPlayer = new window.YT.Player('youtube-player', {\n        height: '100%',\n        width: '100%',\n        videoId: videoId,\n        playerVars: {\n          autoplay: shouldAutoplay ? 1 : 0,\n          controls: 1,\n          rel: 0\n        },\n        events: {\n          onReady: () => {\n            setIsPlayerReady(true);\n            if (shouldAutoplay) {\n              try {\n                newPlayer.playVideo();\n                updatePlayingState(true);\n              } catch (error) {\n                console.error('Erro ao iniciar reprodução:', error);\n                updatePlayingState(false);\n              }\n            }\n          },\n          onStateChange: event => {\n            try {\n              if (event.data === window.YT.PlayerState.ENDED) {\n                updatePlayingState(false);\n                onEnded === null || onEnded === void 0 ? void 0 : onEnded();\n              } else if (event.data === window.YT.PlayerState.PLAYING) {\n                updatePlayingState(true);\n              } else if (event.data === window.YT.PlayerState.PAUSED) {\n                updatePlayingState(false);\n              }\n            } catch (error) {\n              console.error('Erro ao processar mudança de estado:', error);\n              updatePlayingState(false);\n            }\n          },\n          onError: error => {\n            console.error('Erro no player do YouTube:', error);\n            setError('Erro ao carregar o vídeo');\n            updatePlayingState(false);\n          }\n        }\n      });\n      setPlayer(newPlayer);\n      return newPlayer;\n    } catch (error) {\n      console.error('Erro ao inicializar player:', error);\n      setError('Erro ao inicializar o player de vídeo');\n      updatePlayingState(false);\n      return null;\n    }\n  };\n  useEffect(() => {\n    if (selectedVideo || videos[0]) {\n      var _videos$;\n      const videoId = extractVideoId((selectedVideo === null || selectedVideo === void 0 ? void 0 : selectedVideo.url) || ((_videos$ = videos[0]) === null || _videos$ === void 0 ? void 0 : _videos$.url));\n      if (videoId) {\n        initializePlayer(videoId, shouldAutoplay);\n      }\n    }\n    return () => {\n      if (player) {\n        try {\n          player.destroy();\n          setPlayer(null);\n          setIsPlayerReady(false);\n        } catch (error) {\n          console.error('Erro ao destruir player:', error);\n        }\n      }\n    };\n  }, [selectedVideo === null || selectedVideo === void 0 ? void 0 : selectedVideo.url, (_videos$2 = videos[0]) === null || _videos$2 === void 0 ? void 0 : _videos$2.url]);\n  const handleVideoSelect = async (video, shouldAutoplay = false) => {\n    try {\n      console.log('handleVideoSelect chamado com autoplay:', shouldAutoplay);\n      const videoId = extractVideoId(video.url);\n      if (!videoId) {\n        console.error('VideoId não encontrado para:', video.url);\n        return;\n      }\n      if (player && isPlayerReady) {\n        console.log('Player existente, carregando novo vídeo');\n        try {\n          player.loadVideoById({\n            videoId: videoId,\n            startSeconds: 0,\n            suggestedQuality: 'large'\n          });\n          if (shouldAutoplay) {\n            console.log('Iniciando reprodução com player existente');\n            player.playVideo();\n            updatePlayingState(true);\n          }\n        } catch (e) {\n          console.error('Erro ao carregar vídeo:', e);\n        }\n      } else {\n        console.log('Inicializando novo player');\n        try {\n          const newPlayer = await initializePlayer(videoId, true);\n          if (newPlayer) {\n            console.log('Novo player criado, iniciando reprodução');\n            newPlayer.playVideo();\n            updatePlayingState(true);\n          }\n        } catch (e) {\n          console.error('Erro ao inicializar novo player:', e);\n        }\n      }\n    } catch (error) {\n      console.error('Erro em handleVideoSelect:', error);\n    }\n  };\n  const loadVideos = async () => {\n    try {\n      setIsLoading(true);\n      const data = await videoService.getVideos();\n      setVideos(data);\n      if (data.length > 0 && !selectedVideo) {\n        setSelectedVideo(data[0]);\n      }\n    } catch (error) {\n      console.error('Erro ao carregar vídeos:', error);\n      setError('Erro ao carregar a lista de vídeos');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const handleSearch = async searchTerm => {\n    try {\n      setIsLoading(true);\n      const searchResults = await videoService.searchVideos(searchTerm);\n      setVideos(searchResults);\n    } catch (error) {\n      console.error('Erro na busca:', error);\n      setError('Erro ao buscar vídeos');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const handleAddVideo = async () => {\n    if (!newVideoUrl.trim()) return;\n    try {\n      setIsLoading(true);\n      const videoId = extractVideoId(newVideoUrl);\n      if (!videoId) {\n        setError('URL do vídeo inválida');\n        return;\n      }\n      await videoService.addVideo(newVideoUrl);\n      setNewVideoUrl('');\n      await loadVideos();\n    } catch (error) {\n      console.error('Erro ao adicionar vídeo:', error);\n      setError('Erro ao adicionar vídeo');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const extractVideoId = url => {\n    const patterns = [/(?:youtube\\.com\\/watch\\?v=|youtu.be\\/)([^&\\n?#]+)/, /youtube.com\\/embed\\/([^&\\n?#]+)/];\n    for (const pattern of patterns) {\n      const match = url.match(pattern);\n      if (match && match[1]) {\n        return match[1];\n      }\n    }\n    return null;\n  };\n  useEffect(() => {\n    const handleAudioPlay = () => {\n      if (isPlayerReady && player) {\n        fadeIframeVolume(1, 0.10, 500);\n      }\n    };\n    const handleAudioStop = () => {\n      if (isPlayerReady && player) {\n        fadeIframeVolume(0.10, 1, 500);\n      }\n    };\n    window.addEventListener('audioPlay', handleAudioPlay);\n    window.addEventListener('audioStop', handleAudioStop);\n    return () => {\n      window.removeEventListener('audioPlay', handleAudioPlay);\n      window.removeEventListener('audioStop', handleAudioStop);\n    };\n  }, [isPlayerReady, player]);\n  const fadeIframeVolume = (start, end, duration) => {\n    if (!player || !isPlayerReady) return;\n    const steps = 20;\n    const stepValue = (end - start) / steps;\n    const stepDuration = duration / steps;\n    let currentStep = 0;\n    const fadeInterval = setInterval(() => {\n      currentStep++;\n      const newVolume = start + stepValue * currentStep;\n      const volume = Math.min(Math.max(newVolume, 0), 1) * 100;\n      player.setVolume(volume);\n      if (currentStep >= steps) {\n        clearInterval(fadeInterval);\n      }\n    }, stepDuration);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-player-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"main-content\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"video-container\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          id: \"youtube-player\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 325,\n          columnNumber: 11\n        }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"error-message\",\n          children: error\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 326,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 324,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"video-controls\",\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setIsSidebarOpen(!isSidebarOpen),\n          children: isSidebarOpen ? 'Fechar Menu' : 'Abrir Menu'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 329,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 328,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 323,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoSidebar, {\n      isOpen: isSidebarOpen,\n      videos: videos,\n      onVideoSelect: video => handleVideoSelect(video, true),\n      onSearch: handleSearch,\n      onAddVideo: handleAddVideo,\n      newVideoUrl: newVideoUrl,\n      setNewVideoUrl: setNewVideoUrl,\n      isLoading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 335,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 322,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoPlayer, \"x5p5rc3TI5TECFbZ5wKpHZObrdc=\");\n_c = VideoPlayer;\nexport default VideoPlayer;\nvar _c;\n$RefreshReg$(_c, \"VideoPlayer\");","map":{"version":3,"names":["React","useState","useEffect","videoService","VideoSidebar","jsxDEV","_jsxDEV","VideoPlayer","videoId","onEnded","autoplay","isPlaying","setIsPlaying","shouldAutoplay","_s","_videos$2","videos","setVideos","newVideoUrl","setNewVideoUrl","error","setError","isLoading","setIsLoading","isSidebarOpen","setIsSidebarOpen","selectedVideo","setSelectedVideo","player","setPlayer","isPlayerReady","setIsPlayerReady","localIsPlaying","setLocalIsPlaying","updatePlayingState","state","loadVideos","loadYouTubeAPI","Promise","resolve","_firstScriptTag$paren","existingScript","document","querySelector","window","YT","Player","tag","createElement","src","async","firstScriptTag","getElementsByTagName","parentNode","insertBefore","onYouTubeIframeAPIReady","initializePlayer","_YT","destroy","e","console","playerContainer","getElementById","firstChild","removeChild","newPlayer","height","width","playerVars","controls","rel","events","onReady","playVideo","onStateChange","event","data","PlayerState","ENDED","PLAYING","PAUSED","onError","_videos$","extractVideoId","url","handleVideoSelect","video","log","loadVideoById","startSeconds","suggestedQuality","getVideos","length","handleSearch","searchTerm","searchResults","searchVideos","handleAddVideo","trim","addVideo","patterns","pattern","match","handleAudioPlay","fadeIframeVolume","handleAudioStop","addEventListener","removeEventListener","start","end","duration","steps","stepValue","stepDuration","currentStep","fadeInterval","setInterval","newVolume","volume","Math","min","max","setVolume","clearInterval","className","children","id","fileName","_jsxFileName","lineNumber","columnNumber","onClick","isOpen","onVideoSelect","onSearch","onAddVideo","_c","$RefreshReg$"],"sources":["C:/Users/genil/Desktop/sistema da imperio/src/components/VideoPlayer.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { videoService, VideoData } from '../lib/supabase';\nimport VideoSidebar from './VideoSidebar';\n\ninterface VideoPlayerProps {\n  videoId: string;\n  onEnded?: () => void;\n  autoplay?: boolean;\n  isPlaying?: boolean;\n  setIsPlaying?: (playing: boolean) => void;\n  shouldAutoplay?: boolean;\n}\n\nexport const VideoPlayer: React.FC<VideoPlayerProps> = ({ \n  videoId, \n  onEnded,\n  autoplay = false,\n  isPlaying = false,\n  setIsPlaying = () => {},\n  shouldAutoplay = false\n}) => {\n  const [videos, setVideos] = useState<VideoData[]>([]);\n  const [newVideoUrl, setNewVideoUrl] = useState('');\n  const [error, setError] = useState<string>('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\n  const [selectedVideo, setSelectedVideo] = useState<VideoData | null>(null);\n  const [player, setPlayer] = useState<any>(null);\n  const [isPlayerReady, setIsPlayerReady] = useState(false);\n  const [localIsPlaying, setLocalIsPlaying] = useState(isPlaying);\n\n  const updatePlayingState = (state: boolean) => {\n    setLocalIsPlaying(state);\n    setIsPlaying(state);\n  };\n\n  useEffect(() => {\n    loadVideos();\n  }, []);\n\n  const loadYouTubeAPI = () => {\n    return new Promise<void>((resolve) => {\n      const existingScript = document.querySelector('script[src=\"https://www.youtube.com/iframe_api\"]');\n      if (existingScript) {\n        if ((window as any).YT && (window as any).YT.Player) {\n          resolve();\n          return;\n        }\n      }\n\n      const tag = document.createElement('script');\n      tag.src = 'https://www.youtube.com/iframe_api';\n      tag.async = true;\n      const firstScriptTag = document.getElementsByTagName('script')[0];\n      firstScriptTag.parentNode?.insertBefore(tag, firstScriptTag);\n\n      (window as any).onYouTubeIframeAPIReady = () => {\n        resolve();\n      };\n    });\n  };\n\n  const initializePlayer = async (videoId?: string, shouldAutoplay: boolean = false) => {\n    try {\n      await loadYouTubeAPI();\n      \n      if (!(window as any).YT?.Player) {\n        setError('API do YouTube não está disponível');\n        return null;\n      }\n\n      if (player) {\n        try {\n          player.destroy();\n        } catch (e) {\n          console.error('Erro ao destruir player existente:', e);\n        }\n        setPlayer(null);\n      }\n\n      const playerContainer = document.getElementById('youtube-player');\n      if (!playerContainer) {\n        setError('Container do player não encontrado');\n        return null;\n      }\n\n      // Limpa o container antes de criar um novo player\n      while (playerContainer.firstChild) {\n        playerContainer.removeChild(playerContainer.firstChild);\n      }\n\n      const newPlayer = new (window as any).YT.Player('youtube-player', {\n        height: '100%',\n        width: '100%',\n        videoId: videoId,\n        playerVars: {\n          autoplay: shouldAutoplay ? 1 : 0,\n          controls: 1,\n          rel: 0,\n        },\n        events: {\n          onReady: () => {\n            setIsPlayerReady(true);\n            if (shouldAutoplay) {\n              try {\n                newPlayer.playVideo();\n                updatePlayingState(true);\n              } catch (error) {\n                console.error('Erro ao iniciar reprodução:', error);\n                updatePlayingState(false);\n              }\n            }\n          },\n          onStateChange: (event: any) => {\n            try {\n              if (event.data === (window as any).YT.PlayerState.ENDED) {\n                updatePlayingState(false);\n                onEnded?.();\n              } else if (event.data === (window as any).YT.PlayerState.PLAYING) {\n                updatePlayingState(true);\n              } else if (event.data === (window as any).YT.PlayerState.PAUSED) {\n                updatePlayingState(false);\n              }\n            } catch (error) {\n              console.error('Erro ao processar mudança de estado:', error);\n              updatePlayingState(false);\n            }\n          },\n          onError: (error: any) => {\n            console.error('Erro no player do YouTube:', error);\n            setError('Erro ao carregar o vídeo');\n            updatePlayingState(false);\n          }\n        }\n      });\n\n      setPlayer(newPlayer);\n      return newPlayer;\n    } catch (error) {\n      console.error('Erro ao inicializar player:', error);\n      setError('Erro ao inicializar o player de vídeo');\n      updatePlayingState(false);\n      return null;\n    }\n  };\n\n  useEffect(() => {\n    if (selectedVideo || videos[0]) {\n      const videoId = extractVideoId(selectedVideo?.url || videos[0]?.url);\n      if (videoId) {\n        initializePlayer(videoId, shouldAutoplay);\n      }\n    }\n\n    return () => {\n      if (player) {\n        try {\n          player.destroy();\n          setPlayer(null);\n          setIsPlayerReady(false);\n        } catch (error) {\n          console.error('Erro ao destruir player:', error);\n        }\n      }\n    };\n  }, [selectedVideo?.url, videos[0]?.url]);\n\n  const handleVideoSelect = async (video: VideoData, shouldAutoplay: boolean = false) => {\n    try {\n      console.log('handleVideoSelect chamado com autoplay:', shouldAutoplay);\n      \n      const videoId = extractVideoId(video.url);\n      if (!videoId) {\n        console.error('VideoId não encontrado para:', video.url);\n        return;\n      }\n\n      if (player && isPlayerReady) {\n        console.log('Player existente, carregando novo vídeo');\n        try {\n          player.loadVideoById({\n            videoId: videoId,\n            startSeconds: 0,\n            suggestedQuality: 'large'\n          });\n          \n          if (shouldAutoplay) {\n            console.log('Iniciando reprodução com player existente');\n            player.playVideo();\n            updatePlayingState(true);\n          }\n        } catch (e) {\n          console.error('Erro ao carregar vídeo:', e);\n        }\n      } else {\n        console.log('Inicializando novo player');\n        try {\n          const newPlayer = await initializePlayer(videoId, true);\n          if (newPlayer) {\n            console.log('Novo player criado, iniciando reprodução');\n            newPlayer.playVideo();\n            updatePlayingState(true);\n          }\n        } catch (e) {\n          console.error('Erro ao inicializar novo player:', e);\n        }\n      }\n    } catch (error) {\n      console.error('Erro em handleVideoSelect:', error);\n    }\n  };\n\n  const loadVideos = async () => {\n    try {\n      setIsLoading(true);\n      const data = await videoService.getVideos();\n      setVideos(data);\n      if (data.length > 0 && !selectedVideo) {\n        setSelectedVideo(data[0]);\n      }\n    } catch (error) {\n      console.error('Erro ao carregar vídeos:', error);\n      setError('Erro ao carregar a lista de vídeos');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleSearch = async (searchTerm: string) => {\n    try {\n      setIsLoading(true);\n      const searchResults = await videoService.searchVideos(searchTerm);\n      setVideos(searchResults);\n    } catch (error) {\n      console.error('Erro na busca:', error);\n      setError('Erro ao buscar vídeos');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleAddVideo = async () => {\n    if (!newVideoUrl.trim()) return;\n\n    try {\n      setIsLoading(true);\n      const videoId = extractVideoId(newVideoUrl);\n      if (!videoId) {\n        setError('URL do vídeo inválida');\n        return;\n      }\n\n      await videoService.addVideo(newVideoUrl);\n      setNewVideoUrl('');\n      await loadVideos();\n    } catch (error) {\n      console.error('Erro ao adicionar vídeo:', error);\n      setError('Erro ao adicionar vídeo');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const extractVideoId = (url: string): string | null => {\n    const patterns = [\n      /(?:youtube\\.com\\/watch\\?v=|youtu.be\\/)([^&\\n?#]+)/,\n      /youtube.com\\/embed\\/([^&\\n?#]+)/,\n    ];\n\n    for (const pattern of patterns) {\n      const match = url.match(pattern);\n      if (match && match[1]) {\n        return match[1];\n      }\n    }\n    return null;\n  };\n\n  useEffect(() => {\n    const handleAudioPlay = () => {\n      if (isPlayerReady && player) {\n        fadeIframeVolume(1, 0.10, 500);\n      }\n    };\n\n    const handleAudioStop = () => {\n      if (isPlayerReady && player) {\n        fadeIframeVolume(0.10, 1, 500);\n      }\n    };\n\n    window.addEventListener('audioPlay', handleAudioPlay);\n    window.addEventListener('audioStop', handleAudioStop);\n\n    return () => {\n      window.removeEventListener('audioPlay', handleAudioPlay);\n      window.removeEventListener('audioStop', handleAudioStop);\n    };\n  }, [isPlayerReady, player]);\n\n  const fadeIframeVolume = (start: number, end: number, duration: number) => {\n    if (!player || !isPlayerReady) return;\n\n    const steps = 20;\n    const stepValue = (end - start) / steps;\n    const stepDuration = duration / steps;\n    let currentStep = 0;\n\n    const fadeInterval = setInterval(() => {\n      currentStep++;\n      const newVolume = start + (stepValue * currentStep);\n      const volume = Math.min(Math.max(newVolume, 0), 1) * 100;\n      player.setVolume(volume);\n\n      if (currentStep >= steps) {\n        clearInterval(fadeInterval);\n      }\n    }, stepDuration);\n  };\n\n  return (\n    <div className=\"video-player-container\">\n      <div className=\"main-content\">\n        <div className=\"video-container\">\n          <div id=\"youtube-player\"></div>\n          {error && <div className=\"error-message\">{error}</div>}\n        </div>\n        <div className=\"video-controls\">\n          <button onClick={() => setIsSidebarOpen(!isSidebarOpen)}>\n            {isSidebarOpen ? 'Fechar Menu' : 'Abrir Menu'}\n          </button>\n        </div>\n      </div>\n      \n      <VideoSidebar \n        isOpen={isSidebarOpen}\n        videos={videos}\n        onVideoSelect={(video) => handleVideoSelect(video, true)}\n        onSearch={handleSearch}\n        onAddVideo={handleAddVideo}\n        newVideoUrl={newVideoUrl}\n        setNewVideoUrl={setNewVideoUrl}\n        isLoading={isLoading}\n      />\n    </div>\n  );\n};\n\nexport default VideoPlayer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}