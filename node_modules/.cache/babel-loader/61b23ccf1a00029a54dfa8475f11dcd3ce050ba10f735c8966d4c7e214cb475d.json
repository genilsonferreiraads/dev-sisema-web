{"ast":null,"code":"import { createClient } from '@supabase/supabase-js';\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Faltam variáveis de ambiente do Supabase');\n}\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\nexport const audioService = {\n  getAudios: async () => {\n    const {\n      data,\n      error\n    } = await supabase.from('audios').select('*').order('created_at', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data || [];\n  },\n  addAudio: async audio => {\n    console.log('Tentando adicionar áudio com dados:', audio);\n    const {\n      data,\n      error\n    } = await supabase.from('audios').insert([{\n      title: audio.title,\n      url: audio.url,\n      auto_repeat: false,\n      repeat_interval: 0,\n      play_count: 0\n    }]).select().single();\n    if (error) {\n      console.error('Erro ao adicionar áudio:', error);\n      throw error;\n    }\n    if (!data) {\n      throw new Error('Nenhum dado retornado após inserção');\n    }\n    return data;\n  },\n  deleteAudio: async id => {\n    const {\n      error\n    } = await supabase.from('audios').delete().eq('id', id);\n    if (error) throw error;\n  },\n  updateAudio: async (id, updates) => {\n    const {\n      data,\n      error\n    } = await supabase.from('audios').update(updates).eq('id', id).select().single();\n    if (error) throw error;\n    return data;\n  },\n  updatePreferences: async (audioId, preferences) => {\n    const {\n      data,\n      error\n    } = await supabase.from('audios').update(preferences).eq('id', audioId).select().single();\n    if (error) throw error;\n    return data;\n  },\n  loadPreferences: async audioId => {\n    const {\n      data,\n      error\n    } = await supabase.from('audios').select('auto_repeat, repeat_interval, last_played_at, play_count, timer_end_at').eq('id', audioId).single();\n    if (error) throw error;\n    return data;\n  },\n  getAudio: async audioId => {\n    const {\n      data,\n      error\n    } = await supabase.from('audios').select('*').eq('id', audioId).single();\n    if (error) {\n      console.error('Erro ao buscar áudio:', error);\n      return null;\n    }\n    return data;\n  }\n};\nexport const videoService = {\n  async updateVideoOrder(videoId) {\n    try {\n      // 1. Primeiro, pega todos os vídeos ordenados\n      const {\n        data: allVideos\n      } = await supabase.from('videos').select('id, play_order').order('play_order', {\n        ascending: false\n      });\n      if (!allVideos) return;\n\n      // 2. Encontra o vídeo atual e sua posição\n      const currentVideo = allVideos.find(v => v.id === videoId);\n      if (!currentVideo) return;\n\n      // 3. Atualiza a ordem dos vídeos em lote\n      const updates = allVideos.map((video, index) => {\n        if (video.id === videoId) {\n          // Vídeo selecionado vai para o topo\n          return {\n            id: video.id,\n            play_order: allVideos.length,\n            last_played: new Date().toISOString()\n          };\n        } else if (video.play_order > currentVideo.play_order) {\n          // Vídeos acima do selecionado mantêm sua posição\n          return {\n            id: video.id,\n            play_order: video.play_order\n          };\n        } else {\n          // Vídeos abaixo do selecionado descem uma posição\n          return {\n            id: video.id,\n            play_order: (video.play_order || 0) - 1\n          };\n        }\n      });\n\n      // 4. Executa as atualizações\n      for (const update of updates) {\n        await supabase.from('videos').update({\n          play_order: update.play_order,\n          ...(update.last_played ? {\n            last_played: update.last_played\n          } : {})\n        }).eq('id', update.id);\n      }\n    } catch (error) {\n      console.error('Erro ao atualizar ordem do vídeo:', error);\n      throw error;\n    }\n  },\n  async addVideo(url, title) {\n    try {\n      // 1. Primeiro, incrementa a ordem de todos os vídeos existentes\n      const {\n        data: existingVideos\n      } = await supabase.from('videos').select('id, play_order').order('play_order', {\n        ascending: false\n      });\n      if (existingVideos) {\n        for (const video of existingVideos) {\n          await supabase.from('videos').update({\n            play_order: (video.play_order || 0) - 1\n          }).eq('id', video.id);\n        }\n      }\n\n      // 2. Adiciona o novo vídeo com a maior ordem\n      const {\n        data,\n        error\n      } = await supabase.from('videos').insert([{\n        url,\n        title,\n        play_order: (existingVideos === null || existingVideos === void 0 ? void 0 : existingVideos.length) || 0,\n        last_played: new Date().toISOString()\n      }]).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Erro ao adicionar vídeo:', error);\n      throw error;\n    }\n  },\n  async deleteVideo(id) {\n    try {\n      // Primeiro, pega a ordem do vídeo que será deletado e todos os vídeos\n      const {\n        data: videos\n      } = await supabase.from('videos').select('id, play_order').order('play_order', {\n        ascending: false\n      });\n      const videoToDelete = videos === null || videos === void 0 ? void 0 : videos.find(v => v.id === id);\n      if (!videoToDelete) return;\n      const deletedOrder = videoToDelete.play_order || 0;\n\n      // Deleta o vídeo\n      const {\n        error: deleteError\n      } = await supabase.from('videos').delete().eq('id', id);\n      if (deleteError) throw deleteError;\n\n      // Atualiza a ordem dos vídeos que estavam depois do vídeo deletado\n      const videosToUpdate = videos === null || videos === void 0 ? void 0 : videos.filter(v => v.id !== id && (v.play_order || 0) < deletedOrder);\n\n      // Atualiza cada vídeo individualmente\n      for (const video of videosToUpdate || []) {\n        await supabase.from('videos').update({\n          play_order: (video.play_order || 0) + 1\n        }).eq('id', video.id);\n      }\n    } catch (error) {\n      console.error('Erro ao deletar vídeo:', error);\n      throw error;\n    }\n  },\n  async getRecentVideos() {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('videos').select('*').order('play_order', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Erro ao buscar vídeos:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["createClient","supabaseUrl","process","env","REACT_APP_SUPABASE_URL","supabaseAnonKey","REACT_APP_SUPABASE_ANON_KEY","Error","supabase","audioService","getAudios","data","error","from","select","order","ascending","addAudio","audio","console","log","insert","title","url","auto_repeat","repeat_interval","play_count","single","deleteAudio","id","delete","eq","updateAudio","updates","update","updatePreferences","audioId","preferences","loadPreferences","getAudio","videoService","updateVideoOrder","videoId","allVideos","currentVideo","find","v","map","video","index","play_order","length","last_played","Date","toISOString","addVideo","existingVideos","deleteVideo","videos","videoToDelete","deletedOrder","deleteError","videosToUpdate","filter","getRecentVideos"],"sources":["C:/Users/genil/Desktop/sistema da imperio/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Faltam variáveis de ambiente do Supabase');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\nexport interface AudioData {\n  id: string;\n  title: string;\n  url: string;\n  created_at: string;\n  auto_repeat: boolean;\n  repeat_interval: number;\n  last_played_at?: string;\n  play_count?: number;\n  timer_end_at?: string;\n}\n\nexport interface VideoData {\n  id: string;\n  url: string;\n  title?: string;\n  created_at: string;\n  play_order?: number;\n  last_played?: string;\n}\n\nexport const audioService = {\n  getAudios: async (): Promise<AudioData[]> => {\n    const { data, error } = await supabase\n      .from('audios')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data || [];\n  },\n\n  addAudio: async (audio: Omit<AudioData, 'id' | 'created_at'>): Promise<AudioData> => {\n    console.log('Tentando adicionar áudio com dados:', audio);\n    \n    const { data, error } = await supabase\n      .from('audios')\n      .insert([{\n        title: audio.title,\n        url: audio.url,\n        auto_repeat: false,\n        repeat_interval: 0,\n        play_count: 0\n      }])\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Erro ao adicionar áudio:', error);\n      throw error;\n    }\n\n    if (!data) {\n      throw new Error('Nenhum dado retornado após inserção');\n    }\n\n    return data as AudioData;\n  },\n\n  deleteAudio: async (id: string): Promise<void> => {\n    const { error } = await supabase\n      .from('audios')\n      .delete()\n      .eq('id', id);\n    \n    if (error) throw error;\n  },\n\n  updateAudio: async (id: string, updates: Partial<AudioData>): Promise<AudioData> => {\n    const { data, error } = await supabase\n      .from('audios')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as AudioData;\n  },\n\n  updatePreferences: async (audioId: string, preferences: {\n    auto_repeat?: boolean;\n    repeat_interval?: number;\n    last_played_at?: string;\n    play_count?: number;\n    timer_end_at?: string;\n  }): Promise<AudioData> => {\n    const { data, error } = await supabase\n      .from('audios')\n      .update(preferences)\n      .eq('id', audioId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as AudioData;\n  },\n\n  loadPreferences: async (audioId: string): Promise<{\n    auto_repeat: boolean;\n    repeat_interval: number;\n    last_played_at?: string;\n    play_count: number;\n    timer_end_at?: string;\n  }> => {\n    const { data, error } = await supabase\n      .from('audios')\n      .select('auto_repeat, repeat_interval, last_played_at, play_count, timer_end_at')\n      .eq('id', audioId)\n      .single();\n\n    if (error) throw error;\n    return data;\n  },\n\n  getAudio: async (audioId: string): Promise<AudioData | null> => {\n    const { data, error } = await supabase\n      .from('audios')\n      .select('*')\n      .eq('id', audioId)\n      .single();\n      \n    if (error) {\n      console.error('Erro ao buscar áudio:', error);\n      return null;\n    }\n    \n    return data;\n  }\n};\n\nexport const videoService = {\n  async updateVideoOrder(videoId: string): Promise<void> {\n    try {\n      // 1. Primeiro, pega todos os vídeos ordenados\n      const { data: allVideos } = await supabase\n        .from('videos')\n        .select('id, play_order')\n        .order('play_order', { ascending: false });\n\n      if (!allVideos) return;\n\n      // 2. Encontra o vídeo atual e sua posição\n      const currentVideo = allVideos.find(v => v.id === videoId);\n      if (!currentVideo) return;\n\n      // 3. Atualiza a ordem dos vídeos em lote\n      const updates = allVideos.map((video, index) => {\n        if (video.id === videoId) {\n          // Vídeo selecionado vai para o topo\n          return {\n            id: video.id,\n            play_order: allVideos.length,\n            last_played: new Date().toISOString()\n          };\n        } else if (video.play_order > currentVideo.play_order) {\n          // Vídeos acima do selecionado mantêm sua posição\n          return {\n            id: video.id,\n            play_order: video.play_order\n          };\n        } else {\n          // Vídeos abaixo do selecionado descem uma posição\n          return {\n            id: video.id,\n            play_order: (video.play_order || 0) - 1\n          };\n        }\n      });\n\n      // 4. Executa as atualizações\n      for (const update of updates) {\n        await supabase\n          .from('videos')\n          .update({ \n            play_order: update.play_order,\n            ...(update.last_played ? { last_played: update.last_played } : {})\n          })\n          .eq('id', update.id);\n      }\n    } catch (error) {\n      console.error('Erro ao atualizar ordem do vídeo:', error);\n      throw error;\n    }\n  },\n\n  async addVideo(url: string, title: string): Promise<VideoData> {\n    try {\n      // 1. Primeiro, incrementa a ordem de todos os vídeos existentes\n      const { data: existingVideos } = await supabase\n        .from('videos')\n        .select('id, play_order')\n        .order('play_order', { ascending: false });\n\n      if (existingVideos) {\n        for (const video of existingVideos) {\n          await supabase\n            .from('videos')\n            .update({ play_order: (video.play_order || 0) - 1 })\n            .eq('id', video.id);\n        }\n      }\n\n      // 2. Adiciona o novo vídeo com a maior ordem\n      const { data, error } = await supabase\n        .from('videos')\n        .insert([\n          { \n            url, \n            title, \n            play_order: existingVideos?.length || 0,\n            last_played: new Date().toISOString()\n          }\n        ])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Erro ao adicionar vídeo:', error);\n      throw error;\n    }\n  },\n\n  async deleteVideo(id: string): Promise<void> {\n    try {\n      // Primeiro, pega a ordem do vídeo que será deletado e todos os vídeos\n      const { data: videos } = await supabase\n        .from('videos')\n        .select('id, play_order')\n        .order('play_order', { ascending: false });\n\n      const videoToDelete = videos?.find(v => v.id === id);\n      if (!videoToDelete) return;\n\n      const deletedOrder = videoToDelete.play_order || 0;\n\n      // Deleta o vídeo\n      const { error: deleteError } = await supabase\n        .from('videos')\n        .delete()\n        .eq('id', id);\n\n      if (deleteError) throw deleteError;\n\n      // Atualiza a ordem dos vídeos que estavam depois do vídeo deletado\n      const videosToUpdate = videos?.filter(v => \n        v.id !== id && \n        (v.play_order || 0) < deletedOrder\n      );\n\n      // Atualiza cada vídeo individualmente\n      for (const video of videosToUpdate || []) {\n        await supabase\n          .from('videos')\n          .update({ play_order: (video.play_order || 0) + 1 })\n          .eq('id', video.id);\n      }\n    } catch (error) {\n      console.error('Erro ao deletar vídeo:', error);\n      throw error;\n    }\n  },\n\n  async getRecentVideos(): Promise<VideoData[]> {\n    try {\n      const { data, error } = await supabase\n        .from('videos')\n        .select('*')\n        .order('play_order', { ascending: false });\n\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Erro ao buscar vídeos:', error);\n      throw error;\n    }\n  },\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}